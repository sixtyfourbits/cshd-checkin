"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iron-webcrypto";
exports.ids = ["vendor-chunks/iron-webcrypto"];
exports.modules = {

/***/ "(rsc)/./node_modules/iron-webcrypto/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/iron-webcrypto/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   algorithms: () => (/* binding */ algorithms),\n/* harmony export */   base64urlDecode: () => (/* binding */ base64urlDecode),\n/* harmony export */   base64urlEncode: () => (/* binding */ base64urlEncode),\n/* harmony export */   bufferToString: () => (/* binding */ bufferToString),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   encrypt: () => (/* binding */ encrypt),\n/* harmony export */   generateKey: () => (/* binding */ generateKey),\n/* harmony export */   hmacWithPassword: () => (/* binding */ hmacWithPassword),\n/* harmony export */   macFormatVersion: () => (/* binding */ macFormatVersion),\n/* harmony export */   macPrefix: () => (/* binding */ macPrefix),\n/* harmony export */   randomBits: () => (/* binding */ randomBits),\n/* harmony export */   seal: () => (/* binding */ seal),\n/* harmony export */   stringToBuffer: () => (/* binding */ stringToBuffer),\n/* harmony export */   unseal: () => (/* binding */ unseal)\n/* harmony export */ });\n// src/utils.ts\nvar alphabetByEncoding = {};\nvar alphabetByValue = Array.from({ length: 64 });\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"-\"] = 62;\nalphabetByValue[62] = \"-\";\nalphabetByEncoding[\"_\"] = 63;\nalphabetByValue[63] = \"_\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\nvar stringToBuffer = (value) => {\n  return new TextEncoder().encode(value);\n};\nvar bufferToString = (value) => {\n  return new TextDecoder().decode(value);\n};\nvar base64urlDecode = (_input) => {\n  const input = _input + \"=\".repeat((4 - _input.length % 4) % 4);\n  let totalByteLength = input.length / 4 * 3;\n  if (input.endsWith(\"==\")) {\n    totalByteLength -= 2;\n  } else if (input.endsWith(\"=\")) {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] === \"=\") {\n        bits >>= bitsPerLetter;\n      } else {\n        if (!(input[j] in alphabetByEncoding)) {\n          throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n        }\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      }\n    }\n    const chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n  return new Uint8Array(out);\n};\nvar base64urlEncode = (_input) => {\n  const input = typeof _input === \"string\" ? stringToBuffer(_input) : _input;\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n  }\n  return str;\n};\n\n// src/index.ts\nvar defaults = {\n  encryption: { saltBits: 256, algorithm: \"aes-256-cbc\", iterations: 1, minPasswordlength: 32 },\n  integrity: { saltBits: 256, algorithm: \"sha256\", iterations: 1, minPasswordlength: 32 },\n  ttl: 0,\n  timestampSkewSec: 60,\n  localtimeOffsetMsec: 0\n};\nvar clone = (options) => ({\n  ...options,\n  encryption: { ...options.encryption },\n  integrity: { ...options.integrity }\n});\nvar algorithms = {\n  \"aes-128-ctr\": { keyBits: 128, ivBits: 128, name: \"AES-CTR\" },\n  \"aes-256-cbc\": { keyBits: 256, ivBits: 128, name: \"AES-CBC\" },\n  sha256: { keyBits: 256, name: \"SHA-256\" }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = \"Fe26.2\";\nvar randomBytes = (_crypto, size) => {\n  const bytes = new Uint8Array(size);\n  _crypto.getRandomValues(bytes);\n  return bytes;\n};\nvar randomBits = (_crypto, bits) => {\n  if (bits < 1)\n    throw new Error(\"Invalid random bits count\");\n  const bytes = Math.ceil(bits / 8);\n  return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash) => {\n  const passwordBuffer = stringToBuffer(password);\n  const importedKey = await _crypto.subtle.importKey(\n    \"raw\",\n    passwordBuffer,\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveBits\"]\n  );\n  const saltBuffer = stringToBuffer(salt);\n  const params = { name: \"PBKDF2\", hash, salt: saltBuffer, iterations };\n  const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n  return derivation;\n};\nvar generateKey = async (_crypto, password, options) => {\n  var _a;\n  if (!(password == null ? void 0 : password.length))\n    throw new Error(\"Empty password\");\n  if (options == null || typeof options !== \"object\")\n    throw new Error(\"Bad options\");\n  if (!(options.algorithm in algorithms))\n    throw new Error(`Unknown algorithm: ${options.algorithm}`);\n  const algorithm = algorithms[options.algorithm];\n  const result = {};\n  const hmac = (_a = options.hmac) != null ? _a : false;\n  const id = hmac ? { name: \"HMAC\", hash: algorithm.name } : { name: algorithm.name };\n  const usage = hmac ? [\"sign\", \"verify\"] : [\"encrypt\", \"decrypt\"];\n  if (typeof password === \"string\") {\n    if (password.length < options.minPasswordlength)\n      throw new Error(\n        `Password string too short (min ${options.minPasswordlength} characters required)`\n      );\n    let { salt = \"\" } = options;\n    if (!salt) {\n      const { saltBits = 0 } = options;\n      if (!saltBits)\n        throw new Error(\"Missing salt and saltBits options\");\n      const randomSalt = randomBits(_crypto, saltBits);\n      salt = [...new Uint8Array(randomSalt)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n    const derivedKey = await pbkdf2(\n      _crypto,\n      password,\n      salt,\n      options.iterations,\n      algorithm.keyBits / 8,\n      \"SHA-1\"\n    );\n    const importedEncryptionKey = await _crypto.subtle.importKey(\n      \"raw\",\n      derivedKey,\n      id,\n      false,\n      usage\n    );\n    result.key = importedEncryptionKey;\n    result.salt = salt;\n  } else {\n    if (password.length < algorithm.keyBits / 8)\n      throw new Error(\"Key buffer (password) too small\");\n    result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n    result.salt = \"\";\n  }\n  if (options.iv)\n    result.iv = options.iv;\n  else if (\"ivBits\" in algorithm)\n    result.iv = randomBits(_crypto, algorithm.ivBits);\n  return result;\n};\nvar getEncryptParams = (algorithm, key, data) => {\n  return [\n    algorithm === \"aes-128-ctr\" ? { name: \"AES-CTR\", counter: key.iv, length: 128 } : { name: \"AES-CBC\", iv: key.iv },\n    key.key,\n    typeof data === \"string\" ? stringToBuffer(data) : data\n  ];\n};\nvar encrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const encrypted = await _crypto.subtle.encrypt(...getEncryptParams(options.algorithm, key, data));\n  return { encrypted: new Uint8Array(encrypted), key };\n};\nvar decrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const decrypted = await _crypto.subtle.decrypt(...getEncryptParams(options.algorithm, key, data));\n  return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, { ...options, hmac: true });\n  const textBuffer = stringToBuffer(data);\n  const signed = await _crypto.subtle.sign({ name: \"HMAC\" }, key.key, textBuffer);\n  const digest = base64urlEncode(new Uint8Array(signed));\n  return { digest, salt: key.salt };\n};\nvar normalizePassword = (password) => {\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    return { encryption: password, integrity: password };\n  if (\"secret\" in password)\n    return { id: password.id, encryption: password.secret, integrity: password.secret };\n  return { id: password.id, encryption: password.encryption, integrity: password.integrity };\n};\nvar seal = async (_crypto, object, password, options) => {\n  if (!password)\n    throw new Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const objectString = JSON.stringify(object);\n  const pass = normalizePassword(password);\n  const { id = \"\", encryption, integrity } = pass;\n  if (id && !/^\\w+$/.test(id))\n    throw new Error(\"Invalid password id\");\n  const { encrypted, key } = await encrypt(_crypto, encryption, opts.encryption, objectString);\n  const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n  const iv = base64urlEncode(key.iv);\n  const expiration = opts.ttl ? now + opts.ttl : \"\";\n  const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n  const mac = await hmacWithPassword(_crypto, integrity, opts.integrity, macBaseString);\n  const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n  return sealed;\n};\nvar fixedTimeComparison = (a, b) => {\n  let mismatch = a.length === b.length ? 0 : 1;\n  if (mismatch)\n    b = a;\n  for (let i = 0; i < a.length; i += 1)\n    mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options) => {\n  if (!password)\n    throw new Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const parts = sealed.split(\"*\");\n  if (parts.length !== 8)\n    throw new Error(\"Incorrect number of sealed components\");\n  const prefix = parts[0];\n  let passwordId = parts[1];\n  const encryptionSalt = parts[2];\n  const encryptionIv = parts[3];\n  const encryptedB64 = parts[4];\n  const expiration = parts[5];\n  const hmacSalt = parts[6];\n  const hmac = parts[7];\n  const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n  if (macPrefix !== prefix)\n    throw new Error(\"Wrong mac prefix\");\n  if (expiration) {\n    if (!/^\\d+$/.test(expiration))\n      throw new Error(\"Invalid expiration\");\n    const exp = Number.parseInt(expiration, 10);\n    if (exp <= now - opts.timestampSkewSec * 1e3)\n      throw new Error(\"Expired seal\");\n  }\n  let pass = \"\";\n  passwordId = passwordId || \"default\";\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    pass = password;\n  else if (passwordId in password) {\n    pass = password[passwordId];\n  } else {\n    throw new Error(`Cannot find password: ${passwordId}`);\n  }\n  pass = normalizePassword(pass);\n  const macOptions = opts.integrity;\n  macOptions.salt = hmacSalt;\n  const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n  if (!fixedTimeComparison(mac.digest, hmac))\n    throw new Error(\"Bad hmac value\");\n  const encrypted = base64urlDecode(encryptedB64);\n  const decryptOptions = opts.encryption;\n  decryptOptions.salt = encryptionSalt;\n  decryptOptions.iv = base64urlDecode(encryptionIv);\n  const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n  if (decrypted)\n    return JSON.parse(decrypted);\n  return null;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXJvbi13ZWJjcnlwdG8vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DLHNFQUFzRSxvQkFBb0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0JBQW9CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsK0VBQStFO0FBQy9GLGVBQWUsMEVBQTBFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0QsbUJBQW1CLDRDQUE0QztBQUMvRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdCQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQyxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJCQUEyQjtBQUNyRTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnREFBZ0QsSUFBSSw2QkFBNkI7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsd0JBQXdCO0FBQzdFO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVLEdBQUcsR0FBRyxHQUFHLFNBQVMsR0FBRyxHQUFHLEdBQUcsYUFBYSxHQUFHLFdBQVc7QUFDM0Y7QUFDQSxvQkFBb0IsY0FBYyxHQUFHLFNBQVMsR0FBRyxXQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sR0FBRyxXQUFXLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsV0FBVztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlOIiwic291cmNlcyI6WyIvVXNlcnMvcGFya2phZWh5dW5nL0Rlc2t0b3AvQ29kaW5nL2NzaGQvbm9kZV9tb2R1bGVzL2lyb24td2ViY3J5cHRvL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLnRzXG52YXIgYWxwaGFiZXRCeUVuY29kaW5nID0ge307XG52YXIgYWxwaGFiZXRCeVZhbHVlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogNjQgfSk7XG5mb3IgKGxldCBpID0gMCwgc3RhcnQgPSBcIkFcIi5jaGFyQ29kZUF0KDApLCBsaW1pdCA9IFwiWlwiLmNoYXJDb2RlQXQoMCk7IGkgKyBzdGFydCA8PSBsaW1pdDsgaSsrKSB7XG4gIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyBzdGFydCk7XG4gIGFscGhhYmV0QnlFbmNvZGluZ1tjaGFyXSA9IGk7XG4gIGFscGhhYmV0QnlWYWx1ZVtpXSA9IGNoYXI7XG59XG5mb3IgKGxldCBpID0gMCwgc3RhcnQgPSBcImFcIi5jaGFyQ29kZUF0KDApLCBsaW1pdCA9IFwielwiLmNoYXJDb2RlQXQoMCk7IGkgKyBzdGFydCA8PSBsaW1pdDsgaSsrKSB7XG4gIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyBzdGFydCk7XG4gIGNvbnN0IGluZGV4ID0gaSArIDI2O1xuICBhbHBoYWJldEJ5RW5jb2RpbmdbY2hhcl0gPSBpbmRleDtcbiAgYWxwaGFiZXRCeVZhbHVlW2luZGV4XSA9IGNoYXI7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2kudG9TdHJpbmcoMTApXSA9IGkgKyA1MjtcbiAgY29uc3QgY2hhciA9IGkudG9TdHJpbmcoMTApO1xuICBjb25zdCBpbmRleCA9IGkgKyA1MjtcbiAgYWxwaGFiZXRCeUVuY29kaW5nW2NoYXJdID0gaW5kZXg7XG4gIGFscGhhYmV0QnlWYWx1ZVtpbmRleF0gPSBjaGFyO1xufVxuYWxwaGFiZXRCeUVuY29kaW5nW1wiLVwiXSA9IDYyO1xuYWxwaGFiZXRCeVZhbHVlWzYyXSA9IFwiLVwiO1xuYWxwaGFiZXRCeUVuY29kaW5nW1wiX1wiXSA9IDYzO1xuYWxwaGFiZXRCeVZhbHVlWzYzXSA9IFwiX1wiO1xudmFyIGJpdHNQZXJMZXR0ZXIgPSA2O1xudmFyIGJpdHNQZXJCeXRlID0gODtcbnZhciBtYXhMZXR0ZXJWYWx1ZSA9IDYzO1xudmFyIHN0cmluZ1RvQnVmZmVyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufTtcbnZhciBidWZmZXJUb1N0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbn07XG52YXIgYmFzZTY0dXJsRGVjb2RlID0gKF9pbnB1dCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IF9pbnB1dCArIFwiPVwiLnJlcGVhdCgoNCAtIF9pbnB1dC5sZW5ndGggJSA0KSAlIDQpO1xuICBsZXQgdG90YWxCeXRlTGVuZ3RoID0gaW5wdXQubGVuZ3RoIC8gNCAqIDM7XG4gIGlmIChpbnB1dC5lbmRzV2l0aChcIj09XCIpKSB7XG4gICAgdG90YWxCeXRlTGVuZ3RoIC09IDI7XG4gIH0gZWxzZSBpZiAoaW5wdXQuZW5kc1dpdGgoXCI9XCIpKSB7XG4gICAgdG90YWxCeXRlTGVuZ3RoLS07XG4gIH1cbiAgY29uc3Qgb3V0ID0gbmV3IEFycmF5QnVmZmVyKHRvdGFsQnl0ZUxlbmd0aCk7XG4gIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgbGV0IGJpdExlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaiA9IGksIGxpbWl0ID0gaSArIDM7IGogPD0gbGltaXQ7IGorKykge1xuICAgICAgaWYgKGlucHV0W2pdID09PSBcIj1cIikge1xuICAgICAgICBiaXRzID4+PSBiaXRzUGVyTGV0dGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaW5wdXRbal0gaW4gYWxwaGFiZXRCeUVuY29kaW5nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyICR7aW5wdXRbal19IGluIGJhc2U2NCBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0cyB8PSBhbHBoYWJldEJ5RW5jb2RpbmdbaW5wdXRbal1dIDw8IChsaW1pdCAtIGopICogYml0c1BlckxldHRlcjtcbiAgICAgICAgYml0TGVuZ3RoICs9IGJpdHNQZXJMZXR0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT2Zmc2V0ID0gaSAvIDQgKiAzO1xuICAgIGJpdHMgPj49IGJpdExlbmd0aCAlIGJpdHNQZXJCeXRlO1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBNYXRoLmZsb29yKGJpdExlbmd0aCAvIGJpdHNQZXJCeXRlKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGJ5dGVMZW5ndGg7IGsrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gKGJ5dGVMZW5ndGggLSBrIC0gMSkgKiBiaXRzUGVyQnl0ZTtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KGNodW5rT2Zmc2V0ICsgaywgKGJpdHMgJiAyNTUgPDwgb2Zmc2V0KSA+PiBvZmZzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob3V0KTtcbn07XG52YXIgYmFzZTY0dXJsRW5jb2RlID0gKF9pbnB1dCkgPT4ge1xuICBjb25zdCBpbnB1dCA9IHR5cGVvZiBfaW5wdXQgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0J1ZmZlcihfaW5wdXQpIDogX2lucHV0O1xuICBsZXQgc3RyID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBsZXQgYml0TGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBqID0gaSwgbGltaXQgPSBNYXRoLm1pbihpICsgMywgaW5wdXQubGVuZ3RoKTsgaiA8IGxpbWl0OyBqKyspIHtcbiAgICAgIGJpdHMgfD0gaW5wdXRbal0gPDwgKGxpbWl0IC0gaiAtIDEpICogYml0c1BlckJ5dGU7XG4gICAgICBiaXRMZW5ndGggKz0gYml0c1BlckJ5dGU7XG4gICAgfVxuICAgIGNvbnN0IGJpdENsdXN0ZXJDb3VudCA9IE1hdGguY2VpbChiaXRMZW5ndGggLyBiaXRzUGVyTGV0dGVyKTtcbiAgICBiaXRzIDw8PSBiaXRDbHVzdGVyQ291bnQgKiBiaXRzUGVyTGV0dGVyIC0gYml0TGVuZ3RoO1xuICAgIGZvciAobGV0IGsgPSAxOyBrIDw9IGJpdENsdXN0ZXJDb3VudDsgaysrKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoYml0Q2x1c3RlckNvdW50IC0gaykgKiBiaXRzUGVyTGV0dGVyO1xuICAgICAgc3RyICs9IGFscGhhYmV0QnlWYWx1ZVsoYml0cyAmIG1heExldHRlclZhbHVlIDw8IG9mZnNldCkgPj4gb2Zmc2V0XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIGRlZmF1bHRzID0ge1xuICBlbmNyeXB0aW9uOiB7IHNhbHRCaXRzOiAyNTYsIGFsZ29yaXRobTogXCJhZXMtMjU2LWNiY1wiLCBpdGVyYXRpb25zOiAxLCBtaW5QYXNzd29yZGxlbmd0aDogMzIgfSxcbiAgaW50ZWdyaXR5OiB7IHNhbHRCaXRzOiAyNTYsIGFsZ29yaXRobTogXCJzaGEyNTZcIiwgaXRlcmF0aW9uczogMSwgbWluUGFzc3dvcmRsZW5ndGg6IDMyIH0sXG4gIHR0bDogMCxcbiAgdGltZXN0YW1wU2tld1NlYzogNjAsXG4gIGxvY2FsdGltZU9mZnNldE1zZWM6IDBcbn07XG52YXIgY2xvbmUgPSAob3B0aW9ucykgPT4gKHtcbiAgLi4ub3B0aW9ucyxcbiAgZW5jcnlwdGlvbjogeyAuLi5vcHRpb25zLmVuY3J5cHRpb24gfSxcbiAgaW50ZWdyaXR5OiB7IC4uLm9wdGlvbnMuaW50ZWdyaXR5IH1cbn0pO1xudmFyIGFsZ29yaXRobXMgPSB7XG4gIFwiYWVzLTEyOC1jdHJcIjogeyBrZXlCaXRzOiAxMjgsIGl2Qml0czogMTI4LCBuYW1lOiBcIkFFUy1DVFJcIiB9LFxuICBcImFlcy0yNTYtY2JjXCI6IHsga2V5Qml0czogMjU2LCBpdkJpdHM6IDEyOCwgbmFtZTogXCJBRVMtQ0JDXCIgfSxcbiAgc2hhMjU2OiB7IGtleUJpdHM6IDI1NiwgbmFtZTogXCJTSEEtMjU2XCIgfVxufTtcbnZhciBtYWNGb3JtYXRWZXJzaW9uID0gXCIyXCI7XG52YXIgbWFjUHJlZml4ID0gXCJGZTI2LjJcIjtcbnZhciByYW5kb21CeXRlcyA9IChfY3J5cHRvLCBzaXplKSA9PiB7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgcmV0dXJuIGJ5dGVzO1xufTtcbnZhciByYW5kb21CaXRzID0gKF9jcnlwdG8sIGJpdHMpID0+IHtcbiAgaWYgKGJpdHMgPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmFuZG9tIGJpdHMgY291bnRcIik7XG4gIGNvbnN0IGJ5dGVzID0gTWF0aC5jZWlsKGJpdHMgLyA4KTtcbiAgcmV0dXJuIHJhbmRvbUJ5dGVzKF9jcnlwdG8sIGJ5dGVzKTtcbn07XG52YXIgcGJrZGYyID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlMZW5ndGgsIGhhc2gpID0+IHtcbiAgY29uc3QgcGFzc3dvcmRCdWZmZXIgPSBzdHJpbmdUb0J1ZmZlcihwYXNzd29yZCk7XG4gIGNvbnN0IGltcG9ydGVkS2V5ID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgcGFzc3dvcmRCdWZmZXIsXG4gICAgeyBuYW1lOiBcIlBCS0RGMlwiIH0sXG4gICAgZmFsc2UsXG4gICAgW1wiZGVyaXZlQml0c1wiXVxuICApO1xuICBjb25zdCBzYWx0QnVmZmVyID0gc3RyaW5nVG9CdWZmZXIoc2FsdCk7XG4gIGNvbnN0IHBhcmFtcyA9IHsgbmFtZTogXCJQQktERjJcIiwgaGFzaCwgc2FsdDogc2FsdEJ1ZmZlciwgaXRlcmF0aW9ucyB9O1xuICBjb25zdCBkZXJpdmF0aW9uID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhwYXJhbXMsIGltcG9ydGVkS2V5LCBrZXlMZW5ndGggKiA4KTtcbiAgcmV0dXJuIGRlcml2YXRpb247XG59O1xudmFyIGdlbmVyYXRlS2V5ID0gYXN5bmMgKF9jcnlwdG8sIHBhc3N3b3JkLCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYTtcbiAgaWYgKCEocGFzc3dvcmQgPT0gbnVsbCA/IHZvaWQgMCA6IHBhc3N3b3JkLmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgcGFzc3dvcmRcIik7XG4gIGlmIChvcHRpb25zID09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIG9wdGlvbnNcIik7XG4gIGlmICghKG9wdGlvbnMuYWxnb3JpdGhtIGluIGFsZ29yaXRobXMpKVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbGdvcml0aG06ICR7b3B0aW9ucy5hbGdvcml0aG19YCk7XG4gIGNvbnN0IGFsZ29yaXRobSA9IGFsZ29yaXRobXNbb3B0aW9ucy5hbGdvcml0aG1dO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgaG1hYyA9IChfYSA9IG9wdGlvbnMuaG1hYykgIT0gbnVsbCA/IF9hIDogZmFsc2U7XG4gIGNvbnN0IGlkID0gaG1hYyA/IHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IGFsZ29yaXRobS5uYW1lIH0gOiB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH07XG4gIGNvbnN0IHVzYWdlID0gaG1hYyA/IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0gOiBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiXTtcbiAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCBvcHRpb25zLm1pblBhc3N3b3JkbGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUGFzc3dvcmQgc3RyaW5nIHRvbyBzaG9ydCAobWluICR7b3B0aW9ucy5taW5QYXNzd29yZGxlbmd0aH0gY2hhcmFjdGVycyByZXF1aXJlZClgXG4gICAgICApO1xuICAgIGxldCB7IHNhbHQgPSBcIlwiIH0gPSBvcHRpb25zO1xuICAgIGlmICghc2FsdCkge1xuICAgICAgY29uc3QgeyBzYWx0Qml0cyA9IDAgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAoIXNhbHRCaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNhbHQgYW5kIHNhbHRCaXRzIG9wdGlvbnNcIik7XG4gICAgICBjb25zdCByYW5kb21TYWx0ID0gcmFuZG9tQml0cyhfY3J5cHRvLCBzYWx0Qml0cyk7XG4gICAgICBzYWx0ID0gWy4uLm5ldyBVaW50OEFycmF5KHJhbmRvbVNhbHQpXS5tYXAoKHgpID0+IHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVyaXZlZEtleSA9IGF3YWl0IHBia2RmMihcbiAgICAgIF9jcnlwdG8sXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHNhbHQsXG4gICAgICBvcHRpb25zLml0ZXJhdGlvbnMsXG4gICAgICBhbGdvcml0aG0ua2V5Qml0cyAvIDgsXG4gICAgICBcIlNIQS0xXCJcbiAgICApO1xuICAgIGNvbnN0IGltcG9ydGVkRW5jcnlwdGlvbktleSA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAgIFwicmF3XCIsXG4gICAgICBkZXJpdmVkS2V5LFxuICAgICAgaWQsXG4gICAgICBmYWxzZSxcbiAgICAgIHVzYWdlXG4gICAgKTtcbiAgICByZXN1bHQua2V5ID0gaW1wb3J0ZWRFbmNyeXB0aW9uS2V5O1xuICAgIHJlc3VsdC5zYWx0ID0gc2FsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgYWxnb3JpdGhtLmtleUJpdHMgLyA4KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJ1ZmZlciAocGFzc3dvcmQpIHRvbyBzbWFsbFwiKTtcbiAgICByZXN1bHQua2V5ID0gYXdhaXQgX2NyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHBhc3N3b3JkLCBpZCwgZmFsc2UsIHVzYWdlKTtcbiAgICByZXN1bHQuc2FsdCA9IFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaXYpXG4gICAgcmVzdWx0Lml2ID0gb3B0aW9ucy5pdjtcbiAgZWxzZSBpZiAoXCJpdkJpdHNcIiBpbiBhbGdvcml0aG0pXG4gICAgcmVzdWx0Lml2ID0gcmFuZG9tQml0cyhfY3J5cHRvLCBhbGdvcml0aG0uaXZCaXRzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgZ2V0RW5jcnlwdFBhcmFtcyA9IChhbGdvcml0aG0sIGtleSwgZGF0YSkgPT4ge1xuICByZXR1cm4gW1xuICAgIGFsZ29yaXRobSA9PT0gXCJhZXMtMTI4LWN0clwiID8geyBuYW1lOiBcIkFFUy1DVFJcIiwgY291bnRlcjoga2V5Lml2LCBsZW5ndGg6IDEyOCB9IDogeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXY6IGtleS5pdiB9LFxuICAgIGtleS5rZXksXG4gICAgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0J1ZmZlcihkYXRhKSA6IGRhdGFcbiAgXTtcbn07XG52YXIgZW5jcnlwdCA9IGFzeW5jIChfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZW5lcmF0ZUtleShfY3J5cHRvLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gIGNvbnN0IGVuY3J5cHRlZCA9IGF3YWl0IF9jcnlwdG8uc3VidGxlLmVuY3J5cHQoLi4uZ2V0RW5jcnlwdFBhcmFtcyhvcHRpb25zLmFsZ29yaXRobSwga2V5LCBkYXRhKSk7XG4gIHJldHVybiB7IGVuY3J5cHRlZDogbmV3IFVpbnQ4QXJyYXkoZW5jcnlwdGVkKSwga2V5IH07XG59O1xudmFyIGRlY3J5cHQgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2VuZXJhdGVLZXkoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5kZWNyeXB0KC4uLmdldEVuY3J5cHRQYXJhbXMob3B0aW9ucy5hbGdvcml0aG0sIGtleSwgZGF0YSkpO1xuICByZXR1cm4gYnVmZmVyVG9TdHJpbmcobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkKSk7XG59O1xudmFyIGhtYWNXaXRoUGFzc3dvcmQgPSBhc3luYyAoX2NyeXB0bywgcGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2VuZXJhdGVLZXkoX2NyeXB0bywgcGFzc3dvcmQsIHsgLi4ub3B0aW9ucywgaG1hYzogdHJ1ZSB9KTtcbiAgY29uc3QgdGV4dEJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKGRhdGEpO1xuICBjb25zdCBzaWduZWQgPSBhd2FpdCBfY3J5cHRvLnN1YnRsZS5zaWduKHsgbmFtZTogXCJITUFDXCIgfSwga2V5LmtleSwgdGV4dEJ1ZmZlcik7XG4gIGNvbnN0IGRpZ2VzdCA9IGJhc2U2NHVybEVuY29kZShuZXcgVWludDhBcnJheShzaWduZWQpKTtcbiAgcmV0dXJuIHsgZGlnZXN0LCBzYWx0OiBrZXkuc2FsdCB9O1xufTtcbnZhciBub3JtYWxpemVQYXNzd29yZCA9IChwYXNzd29yZCkgPT4ge1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiIHx8IHBhc3N3b3JkIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICByZXR1cm4geyBlbmNyeXB0aW9uOiBwYXNzd29yZCwgaW50ZWdyaXR5OiBwYXNzd29yZCB9O1xuICBpZiAoXCJzZWNyZXRcIiBpbiBwYXNzd29yZClcbiAgICByZXR1cm4geyBpZDogcGFzc3dvcmQuaWQsIGVuY3J5cHRpb246IHBhc3N3b3JkLnNlY3JldCwgaW50ZWdyaXR5OiBwYXNzd29yZC5zZWNyZXQgfTtcbiAgcmV0dXJuIHsgaWQ6IHBhc3N3b3JkLmlkLCBlbmNyeXB0aW9uOiBwYXNzd29yZC5lbmNyeXB0aW9uLCBpbnRlZ3JpdHk6IHBhc3N3b3JkLmludGVncml0eSB9O1xufTtcbnZhciBzZWFsID0gYXN5bmMgKF9jcnlwdG8sIG9iamVjdCwgcGFzc3dvcmQsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFwYXNzd29yZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBwYXNzd29yZFwiKTtcbiAgY29uc3Qgb3B0cyA9IGNsb25lKG9wdGlvbnMpO1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTtcbiAgY29uc3Qgb2JqZWN0U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgY29uc3QgcGFzcyA9IG5vcm1hbGl6ZVBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgY29uc3QgeyBpZCA9IFwiXCIsIGVuY3J5cHRpb24sIGludGVncml0eSB9ID0gcGFzcztcbiAgaWYgKGlkICYmICEvXlxcdyskLy50ZXN0KGlkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhc3N3b3JkIGlkXCIpO1xuICBjb25zdCB7IGVuY3J5cHRlZCwga2V5IH0gPSBhd2FpdCBlbmNyeXB0KF9jcnlwdG8sIGVuY3J5cHRpb24sIG9wdHMuZW5jcnlwdGlvbiwgb2JqZWN0U3RyaW5nKTtcbiAgY29uc3QgZW5jcnlwdGVkQjY0ID0gYmFzZTY0dXJsRW5jb2RlKG5ldyBVaW50OEFycmF5KGVuY3J5cHRlZCkpO1xuICBjb25zdCBpdiA9IGJhc2U2NHVybEVuY29kZShrZXkuaXYpO1xuICBjb25zdCBleHBpcmF0aW9uID0gb3B0cy50dGwgPyBub3cgKyBvcHRzLnR0bCA6IFwiXCI7XG4gIGNvbnN0IG1hY0Jhc2VTdHJpbmcgPSBgJHttYWNQcmVmaXh9KiR7aWR9KiR7a2V5LnNhbHR9KiR7aXZ9KiR7ZW5jcnlwdGVkQjY0fSoke2V4cGlyYXRpb259YDtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1dpdGhQYXNzd29yZChfY3J5cHRvLCBpbnRlZ3JpdHksIG9wdHMuaW50ZWdyaXR5LCBtYWNCYXNlU3RyaW5nKTtcbiAgY29uc3Qgc2VhbGVkID0gYCR7bWFjQmFzZVN0cmluZ30qJHttYWMuc2FsdH0qJHttYWMuZGlnZXN0fWA7XG4gIHJldHVybiBzZWFsZWQ7XG59O1xudmFyIGZpeGVkVGltZUNvbXBhcmlzb24gPSAoYSwgYikgPT4ge1xuICBsZXQgbWlzbWF0Y2ggPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyAwIDogMTtcbiAgaWYgKG1pc21hdGNoKVxuICAgIGIgPSBhO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpXG4gICAgbWlzbWF0Y2ggfD0gYS5jaGFyQ29kZUF0KGkpIF4gYi5jaGFyQ29kZUF0KGkpO1xuICByZXR1cm4gbWlzbWF0Y2ggPT09IDA7XG59O1xudmFyIHVuc2VhbCA9IGFzeW5jIChfY3J5cHRvLCBzZWFsZWQsIHBhc3N3b3JkLCBvcHRpb25zKSA9PiB7XG4gIGlmICghcGFzc3dvcmQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgcGFzc3dvcmRcIik7XG4gIGNvbnN0IG9wdHMgPSBjbG9uZShvcHRpb25zKTtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSArIChvcHRzLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7XG4gIGNvbnN0IHBhcnRzID0gc2VhbGVkLnNwbGl0KFwiKlwiKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gOClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgbnVtYmVyIG9mIHNlYWxlZCBjb21wb25lbnRzXCIpO1xuICBjb25zdCBwcmVmaXggPSBwYXJ0c1swXTtcbiAgbGV0IHBhc3N3b3JkSWQgPSBwYXJ0c1sxXTtcbiAgY29uc3QgZW5jcnlwdGlvblNhbHQgPSBwYXJ0c1syXTtcbiAgY29uc3QgZW5jcnlwdGlvbkl2ID0gcGFydHNbM107XG4gIGNvbnN0IGVuY3J5cHRlZEI2NCA9IHBhcnRzWzRdO1xuICBjb25zdCBleHBpcmF0aW9uID0gcGFydHNbNV07XG4gIGNvbnN0IGhtYWNTYWx0ID0gcGFydHNbNl07XG4gIGNvbnN0IGhtYWMgPSBwYXJ0c1s3XTtcbiAgY29uc3QgbWFjQmFzZVN0cmluZyA9IGAke3ByZWZpeH0qJHtwYXNzd29yZElkfSoke2VuY3J5cHRpb25TYWx0fSoke2VuY3J5cHRpb25Jdn0qJHtlbmNyeXB0ZWRCNjR9KiR7ZXhwaXJhdGlvbn1gO1xuICBpZiAobWFjUHJlZml4ICE9PSBwcmVmaXgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgbWFjIHByZWZpeFwiKTtcbiAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICBpZiAoIS9eXFxkKyQvLnRlc3QoZXhwaXJhdGlvbikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGV4cGlyYXRpb25cIik7XG4gICAgY29uc3QgZXhwID0gTnVtYmVyLnBhcnNlSW50KGV4cGlyYXRpb24sIDEwKTtcbiAgICBpZiAoZXhwIDw9IG5vdyAtIG9wdHMudGltZXN0YW1wU2tld1NlYyAqIDFlMylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGlyZWQgc2VhbFwiKTtcbiAgfVxuICBsZXQgcGFzcyA9IFwiXCI7XG4gIHBhc3N3b3JkSWQgPSBwYXNzd29yZElkIHx8IFwiZGVmYXVsdFwiO1xuICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSBcInN0cmluZ1wiIHx8IHBhc3N3b3JkIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICBwYXNzID0gcGFzc3dvcmQ7XG4gIGVsc2UgaWYgKHBhc3N3b3JkSWQgaW4gcGFzc3dvcmQpIHtcbiAgICBwYXNzID0gcGFzc3dvcmRbcGFzc3dvcmRJZF07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBwYXNzd29yZDogJHtwYXNzd29yZElkfWApO1xuICB9XG4gIHBhc3MgPSBub3JtYWxpemVQYXNzd29yZChwYXNzKTtcbiAgY29uc3QgbWFjT3B0aW9ucyA9IG9wdHMuaW50ZWdyaXR5O1xuICBtYWNPcHRpb25zLnNhbHQgPSBobWFjU2FsdDtcbiAgY29uc3QgbWFjID0gYXdhaXQgaG1hY1dpdGhQYXNzd29yZChfY3J5cHRvLCBwYXNzLmludGVncml0eSwgbWFjT3B0aW9ucywgbWFjQmFzZVN0cmluZyk7XG4gIGlmICghZml4ZWRUaW1lQ29tcGFyaXNvbihtYWMuZGlnZXN0LCBobWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgaG1hYyB2YWx1ZVwiKTtcbiAgY29uc3QgZW5jcnlwdGVkID0gYmFzZTY0dXJsRGVjb2RlKGVuY3J5cHRlZEI2NCk7XG4gIGNvbnN0IGRlY3J5cHRPcHRpb25zID0gb3B0cy5lbmNyeXB0aW9uO1xuICBkZWNyeXB0T3B0aW9ucy5zYWx0ID0gZW5jcnlwdGlvblNhbHQ7XG4gIGRlY3J5cHRPcHRpb25zLml2ID0gYmFzZTY0dXJsRGVjb2RlKGVuY3J5cHRpb25Jdik7XG4gIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGRlY3J5cHQoX2NyeXB0bywgcGFzcy5lbmNyeXB0aW9uLCBkZWNyeXB0T3B0aW9ucywgZW5jcnlwdGVkKTtcbiAgaWYgKGRlY3J5cHRlZClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNyeXB0ZWQpO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCB7IGFsZ29yaXRobXMsIGJhc2U2NHVybERlY29kZSwgYmFzZTY0dXJsRW5jb2RlLCBidWZmZXJUb1N0cmluZywgY2xvbmUsIGRlY3J5cHQsIGRlZmF1bHRzLCBlbmNyeXB0LCBnZW5lcmF0ZUtleSwgaG1hY1dpdGhQYXNzd29yZCwgbWFjRm9ybWF0VmVyc2lvbiwgbWFjUHJlZml4LCByYW5kb21CaXRzLCBzZWFsLCBzdHJpbmdUb0J1ZmZlciwgdW5zZWFsIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iron-webcrypto/dist/index.js\n");

/***/ })

};
;